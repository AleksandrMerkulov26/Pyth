# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год».
# В рамках класса реализовать два метода. Первый, с декоратором @classmethod.
# Он должен извлекать число, месяц, год и преобразовывать их тип к типу «Число».
# Второй, с декоратором @staticmethod, должен проводить валидацию числа, месяца и года (например, месяц — от 1 до 12).
# Проверить работу полученной структуры на реальных данных.
# class Date:
#     def __init__(self, date: str):
#         self.date = date
#
#     @classmethod
#     def preobrazovatel_date(cls, date_str: str):
#         day, month, year = map(int, date_str.split('-'))
#         return day, month, year
#
#     @staticmethod
#     def validate_date(date_str: str):
#         day, month, year = map(int, date_str.split('-'))
#         if (day <= 31 and month <= 12 and year <= 2999) == True:
#             return 'все числа введены корректно'
#         else:
#             return 'числа дат Некорректны'
#
#
# try:
#     my_date = Date(input('Введите дату в формате «день-месяц-год»: '))
#     print(Date.preobrazovatel_date(my_date.date))
#     print(Date.validate_date(my_date.date))
# except ValueError:
#     print('Требуется ввести дату в формате «день-месяц-год»')


# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на ноль.
# Проверьте его работу на данных, вводимых пользователем.
# При вводе нуля в качестве делителя программа должна корректно обработать эту ситуацию и не завершиться с ошибкой.
# class ZeroDivisionException(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
#
# try:
#     a, b = map(int, input('Введите a и b, чтобы разделить их друг на друга: ').split())
#     if b == 0:
#         raise ZeroDivisionException('Деление на ноль запрещено')
#     print(f'Результат деления a/b : {a / b}')
# except ZeroDivisionException as err:
#     print(err)
# except ValueError:
#     print("Вы ввели не число")

#
# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел.
# Проверить работу исключения на реальном примере. Запрашивать у пользователя данные и заполнять список необходимо только числами.
# Класс-исключение должен контролировать типы данных элементов списка.
# Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не остановит работу скрипта, введя, например, команду «stop».
# При этом скрипт завершается, сформированный список с числами выводится на экран.
# Подсказка: для этого задания примем, что пользователь может вводить только числа и строки.
# Во время ввода пользователем очередного элемента необходимо реализовать проверку типа элемента.
# Вносить его в список, только если введено число.
# Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение.
# При этом работа скрипта не должна завершаться.

# class OwnError(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
#     def __str__(self):
#         return self.txt
#
#
# def is_digit(string):  # проверка на целые и десятичные числа
#     if string.isdigit():
#         return True
#     else:
#         try:
#             float(string)
#             return True
#         except ValueError:
#             return False
#
#
# my_list = []
# while True:
#     try:
#         value = input('Введите очередное число в список (нажмите s - для выхода): ')
#         if value == 's':  # если введен 's', то цикл завершается и выводится получившийся список
#             print(f'Result: {my_list}')
#             break
#         if not is_digit(value):  # если введено не число, то вызывается исключение
#             raise OwnError('Введенное значение должно быть числом')
#         my_list.append(float(value)) if '.' in value else my_list.append(int(value))
#     except OwnError as err:
#         print(err)
#
# 4. Начните работу над проектом «Склад оргтехники».
# Создайте класс, описывающий склад.
# А также класс «Оргтехника», который будет базовым для классов-наследников.
# Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс).
# В базовом классе определите параметры, общие для приведённых типов.
# В классах-наследниках реализуйте параметры, уникальные для каждого типа оргтехники.
#
# 5. Продолжить работу над первым заданием.
# Разработайте методы, которые отвечают за приём оргтехники на склад и передачу в определённое подразделение компании.
# Для хранения данных о наименовании и количестве единиц оргтехники, а также других данных, можно использовать любую подходящую структуру (например, словарь).
#
# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных.
# Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.
# Подсказка: постарайтесь реализовать в проекте «Склад оргтехники» максимум возможностей, изученных на уроках по ООП.
#

# 7. Реализовать проект «Операции с комплексными числами».
# Создайте класс «Комплексное число». Реализуйте перегрузку методов сложения и умножения комплексных чисел.
# Проверьте работу проекта.
# Для этого создаёте экземпляры класса (комплексные числа), выполните сложение и умножение созданных экземпляров.
# Проверьте корректность полученного результата.
# Дополнительные материалы

# class OwnError(Exception):
#     def __init__(self, message):
#         self.message = message
#
#     def __str__(self):
#         return self.message
#
#
# class ComplexNum:  # класс «Комплексное число»
#     def __init__(self, a=0, b=0):
#         self._num = complex(a, b)
#
#     @property
#     def num(self):
#         return self._num
#
#     def __add__(self, other):  # перегружаем метод сложения для комплексных чисел
#         try:  # валидация аргументов
#             if isinstance(other, ComplexNum):
#                 return ComplexNum(self.num + other.num)
#             elif isinstance(other, complex):
#                 return ComplexNum(self.num + other)
#             raise OwnError('Введенное число должно быть комплексным')
#         except OwnError as err:
#             print(err)
#
#     def __mul__(self, other):  # перегружаем метод умножения комплексных чисел
#         try:
#             if isinstance(other, ComplexNum):
#                 return ComplexNum(self.num * other.num)
#             elif isinstance(other, complex):
#                 return ComplexNum(self.num * other)
#             raise OwnError('Введенное число должно быть комплексным')
#         except OwnError as err:
#             print(err)
#
#     def __str__(self):
#         return f'результат: {self._num}'
#
#
# x = ComplexNum(1, 2)
# y = ComplexNum(3, 4)
# print(x + y)
# print(x + complex(5, 6))
# print(x * y)
# print(x + 1)